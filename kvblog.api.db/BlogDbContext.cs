using Kvblog.Api.Db.Entities;
using Microsoft.EntityFrameworkCore;

namespace Kvblog.Api.Db
{
    public class BlogDbContext : DbContext
    {
        public DbSet<BlogArticleEntity> BlogArticles { get; set; } = null!;

        public BlogDbContext(DbContextOptions<BlogDbContext> options)
           : base(options)
        {
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            // Seeding data
            modelBuilder.Entity<BlogArticleEntity>().HasData(
                new BlogArticleEntity
                {
                    Id = Guid.Parse("5b0be4d7-90aa-4588-a13e-bf71f7b5ad5f"),
                    Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)1",
                    Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                    Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                    DatePosted = new DateTime(2024, 7, 11, 0, 0, 0, DateTimeKind.Utc),
					DateUpdated = new DateTime(2024, 7, 11, 0, 0, 0, DateTimeKind.Utc),
					Author ="Vasilis K",
                    Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-1"
				},
                new BlogArticleEntity
                {
                    Id = Guid.Parse("bfe0c948-edfe-4216-a274-2a3baf6de542"),
                    Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)2",
                    Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                    Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                    DatePosted = new DateTime(2024, 5, 11, 0, 0, 0, DateTimeKind.Utc),
                    DateUpdated = new DateTime(2024, 5, 11, 0, 0, 0, DateTimeKind.Utc),
                    Author = "Vasilis K",
                    Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-2"
				},
                new BlogArticleEntity
                {
                    Id = Guid.Parse("79df870d-3016-4cc9-8fb7-182315cf9743"),
                    Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)3",
                    Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                    Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                    DatePosted = new DateTime(2024, 4, 11, 0, 0, 0, DateTimeKind.Utc),
                    DateUpdated = new DateTime(2024, 4, 11, 0, 0, 0, DateTimeKind.Utc),
                    Author = "Vasilis K",
                    Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-3"
				},
                new BlogArticleEntity
                {
                    Id = Guid.Parse("d5431b7a-01dc-4d1a-9684-112eeb4a722d"),
                    Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)4",
                    Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                    Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                    DatePosted = new DateTime(2023, 6, 11, 0, 0, 0, DateTimeKind.Utc),
                    DateUpdated =   new DateTime(2023, 6, 11, 0, 0, 0, DateTimeKind.Utc),
                    Author = "Vasilis K",
                    Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-4"
				},
                new BlogArticleEntity
                {
                    Id = Guid.Parse("b9592224-ae00-45eb-af54-e3631c296973"),
                    Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)5",
                    Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                    Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                    DatePosted = new DateTime(2022, 9, 11, 0, 0, 0, DateTimeKind.Utc),
                    DateUpdated = new DateTime(2022, 9, 11, 0, 0, 0, DateTimeKind.Utc),
                    Author = "Vasilis K",
                    Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-5"
				},
                new BlogArticleEntity
                {
                    Id = Guid.Parse("cfc5d387-9c60-485b-ad92-e1480ac81a9f"),
                    Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)6",
                    Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                    Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                    DatePosted = new DateTime(2022, 8, 11, 0, 0, 0, DateTimeKind.Utc),
                    DateUpdated = new DateTime(2022, 8, 11, 0, 0, 0, DateTimeKind.Utc),
                    Author = "Vasilis K",
                    Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-6"
				},
                new BlogArticleEntity
                {
                    Id = Guid.Parse("90ff393f-d868-4df9-9830-47fea72812de"),
                    Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)7",
                    Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                    Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                    DatePosted = new DateTime(2022, 7, 11, 0, 0, 0, DateTimeKind.Utc),
                    DateUpdated = new DateTime(2022, 7, 11, 0, 0, 0, DateTimeKind.Utc),
                    Author = "Vasilis K",
                    Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-7"   
				},
                new BlogArticleEntity
                {
                    Id = Guid.Parse("9a55afdf-1fb3-4518-9843-fa31a947b5f3"),
                    Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)8",
                    Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                    Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                    DatePosted = new DateTime(2022, 6, 11, 0, 0, 0, DateTimeKind.Utc),
                    DateUpdated = new DateTime(2022, 6, 11, 0, 0, 0, DateTimeKind.Utc),
                    Author = "Vasilis K",
                    Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-8"   
				},
                new BlogArticleEntity
                {
                    Id = Guid.Parse("f9796233-836c-427d-9587-e826a1be080b"),
                    Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)9",
                    Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                    Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                    DatePosted = new DateTime(2021, 6, 11, 0, 0, 0, DateTimeKind.Utc),
                    DateUpdated = new DateTime(2021, 6, 11, 0, 0, 0, DateTimeKind.Utc),
                    Author = "Vasilis K",
                    Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-9"
				},
                new BlogArticleEntity
                {
                    Id = Guid.Parse("30c220be-28c7-49a2-945f-d656f7631b1d"),
                    Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)10",
                    Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                    Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                    DatePosted = new DateTime(2020, 6, 11, 0, 0, 0, DateTimeKind.Utc),
                    DateUpdated = new DateTime(2020, 6, 11, 0, 0, 0, DateTimeKind.Utc),
                    Author = "Vasilis K",
                    Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-10"
				}
               );
        }
    }
}