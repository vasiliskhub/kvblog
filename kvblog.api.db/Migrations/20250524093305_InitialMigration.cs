using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

#pragma warning disable CA1814 // Prefer jagged arrays over multidimensional

namespace Kvblog.Api.Db.Migrations
{
    /// <inheritdoc />
    public partial class InitialMigration : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "BlogArticles",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Title = table.Column<string>(type: "character varying(5000)", maxLength: 5000, nullable: false),
                    Description = table.Column<string>(type: "character varying(5000)", maxLength: 5000, nullable: false),
                    Body = table.Column<string>(type: "text", nullable: false),
                    FeaturedImageUrl = table.Column<string>(type: "character varying(1000)", maxLength: 1000, nullable: false),
                    DatePosted = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    DateUpdated = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    Author = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_BlogArticles", x => x.Id);
                });

            migrationBuilder.InsertData(
                table: "BlogArticles",
                columns: new[] { "Id", "Author", "Body", "DatePosted", "DateUpdated", "Description", "FeaturedImageUrl", "Title" },
                values: new object[,]
                {
                    { new Guid("30c220be-28c7-49a2-945f-d656f7631b1d"), "Vasilis K", "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>", new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2632), new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2632), "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.", "defaultArticle.jpg", "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)" },
                    { new Guid("5b0be4d7-90aa-4588-a13e-bf71f7b5ad5f"), "Vasilis K", "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>", new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2612), new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2614), "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.", "defaultArticle.jpg", "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)" },
                    { new Guid("79df870d-3016-4cc9-8fb7-182315cf9743"), "Vasilis K", "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>", new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2618), new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2619), "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.", "defaultArticle.jpg", "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)" },
                    { new Guid("90ff393f-d868-4df9-9830-47fea72812de"), "Vasilis K", "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>", new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2626), new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2626), "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.", "defaultArticle.jpg", "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)" },
                    { new Guid("9a55afdf-1fb3-4518-9843-fa31a947b5f3"), "Vasilis K", "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>", new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2628), new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2628), "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.", "defaultArticle.jpg", "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)" },
                    { new Guid("b9592224-ae00-45eb-af54-e3631c296973"), "Vasilis K", "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>", new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2622), new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2623), "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.", "defaultArticle.jpg", "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)" },
                    { new Guid("bfe0c948-edfe-4216-a274-2a3baf6de542"), "Vasilis K", "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>", new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2616), new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2616), "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.", "defaultArticle.jpg", "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)" },
                    { new Guid("cfc5d387-9c60-485b-ad92-e1480ac81a9f"), "Vasilis K", "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>", new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2624), new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2625), "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.", "defaultArticle.jpg", "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)" },
                    { new Guid("d5431b7a-01dc-4d1a-9684-112eeb4a722d"), "Vasilis K", "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>", new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2620), new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2621), "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.", "defaultArticle.jpg", "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)" },
                    { new Guid("f9796233-836c-427d-9587-e826a1be080b"), "Vasilis K", "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>", new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2630), new DateTime(2025, 5, 24, 9, 33, 5, 504, DateTimeKind.Utc).AddTicks(2630), "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.", "defaultArticle.jpg", "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)" }
                });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "BlogArticles");
        }
    }
}
