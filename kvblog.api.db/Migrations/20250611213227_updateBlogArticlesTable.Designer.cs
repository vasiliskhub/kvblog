// <auto-generated />
using System;
using Kvblog.Api.Db;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace Kvblog.Api.Db.Migrations
{
    [DbContext(typeof(BlogDbContext))]
    [Migration("20250611213227_updateBlogArticlesTable")]
    partial class updateBlogArticlesTable
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.5")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("Kvblog.Api.Db.Entities.BlogArticleEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Author")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<string>("Body")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateTime>("DatePosted")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime>("DateUpdated")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(5000)
                        .HasColumnType("character varying(5000)");

                    b.Property<string>("Slug")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.HasKey("Id");

                    b.ToTable("BlogArticles");

                    b.HasData(
                        new
                        {
                            Id = new Guid("5b0be4d7-90aa-4588-a13e-bf71f7b5ad5f"),
                            Author = "Vasilis K",
                            Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                            DatePosted = new DateTime(2024, 7, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            DateUpdated = new DateTime(2024, 7, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                            Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-1",
                            Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)1"
                        },
                        new
                        {
                            Id = new Guid("bfe0c948-edfe-4216-a274-2a3baf6de542"),
                            Author = "Vasilis K",
                            Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                            DatePosted = new DateTime(2024, 5, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            DateUpdated = new DateTime(2024, 5, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                            Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-2",
                            Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)2"
                        },
                        new
                        {
                            Id = new Guid("79df870d-3016-4cc9-8fb7-182315cf9743"),
                            Author = "Vasilis K",
                            Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                            DatePosted = new DateTime(2024, 4, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            DateUpdated = new DateTime(2024, 4, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                            Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-3",
                            Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)3"
                        },
                        new
                        {
                            Id = new Guid("d5431b7a-01dc-4d1a-9684-112eeb4a722d"),
                            Author = "Vasilis K",
                            Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                            DatePosted = new DateTime(2023, 6, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            DateUpdated = new DateTime(2023, 6, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                            Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-4",
                            Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)4"
                        },
                        new
                        {
                            Id = new Guid("b9592224-ae00-45eb-af54-e3631c296973"),
                            Author = "Vasilis K",
                            Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                            DatePosted = new DateTime(2022, 9, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            DateUpdated = new DateTime(2022, 9, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                            Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-5",
                            Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)5"
                        },
                        new
                        {
                            Id = new Guid("cfc5d387-9c60-485b-ad92-e1480ac81a9f"),
                            Author = "Vasilis K",
                            Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                            DatePosted = new DateTime(2022, 8, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            DateUpdated = new DateTime(2022, 8, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                            Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-6",
                            Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)6"
                        },
                        new
                        {
                            Id = new Guid("90ff393f-d868-4df9-9830-47fea72812de"),
                            Author = "Vasilis K",
                            Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                            DatePosted = new DateTime(2022, 7, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            DateUpdated = new DateTime(2022, 7, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                            Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-7",
                            Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)7"
                        },
                        new
                        {
                            Id = new Guid("9a55afdf-1fb3-4518-9843-fa31a947b5f3"),
                            Author = "Vasilis K",
                            Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                            DatePosted = new DateTime(2022, 6, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            DateUpdated = new DateTime(2022, 6, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                            Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-8",
                            Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)8"
                        },
                        new
                        {
                            Id = new Guid("f9796233-836c-427d-9587-e826a1be080b"),
                            Author = "Vasilis K",
                            Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                            DatePosted = new DateTime(2021, 6, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            DateUpdated = new DateTime(2021, 6, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                            Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-9",
                            Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)9"
                        },
                        new
                        {
                            Id = new Guid("30c220be-28c7-49a2-945f-d656f7631b1d"),
                            Author = "Vasilis K",
                            Body = "<p>The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.</p>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*0R9bESDTwLP8OlKI5qazeg.png\" alt=\"\" width=\"469\" height=\"264\"></p>\r\n<h3 id=\"getting-the-latest-bits\">Getting the latest bits</h3>\r\n<p>You can try out the new features by referencing the latest build of&nbsp;<a href=\"https://www.nuget.org/packages/System.Text.Json\" target=\"_blank\" rel=\"noopener\">System.Text.Json NuGet package</a>&nbsp;or the&nbsp;<a href=\"https://dotnet.microsoft.com/download/dotnet/9.0\" target=\"_blank\" rel=\"noopener\">latest SDK for .NET 9</a>.</p>\r\n<h2 id=\"json-schema-exporter\">JSON Schema Exporter</h2>\r\n<p>The new&nbsp;<code>JsonSchemaExporter</code>&nbsp;class can be used to extract&nbsp;<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON schema</a>&nbsp;documents from .NET types using either&nbsp;<code>JsonSerializerOptions</code>&nbsp;or&nbsp;<code>JsonTypeInfo</code> instances:</p>\r\n<p>&nbsp;</p>\r\n<pre class=\"language-csharp\"><code>using System.Text.Json.Schema;\r\n\r\nJsonSerializerOptions options = JsonSerializerOptions.Default;\r\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(Person));\r\nConsole.WriteLine(schema.ToString());\r\n//{\r\n//  \"type\": [\"object\", \"null\"],\r\n//  \"properties\": {\r\n//    \"Name\": { \"type\": \"string\" },\r\n//    \"Age\": { \"type\": \"integer\" },\r\n//    \"Address\": { \"type\": [\"string\", \"null\"], \"default\": null }\r\n//  },\r\n//  \"required\": [\"Name\", \"Age\"]\r\n//}\r\n\r\nrecord Person(string Name, int Age, string? Address = null);</code></pre>\r\n<p>The resultant schema provides a specification of the JSON serialization contract for the type. As can be seen in this example, it distinguishes between nullable:</p>\r\n<h2 id=\"streaming-multiple-json-documents\">Streaming multiple JSON documents</h2>\r\n<p><code>Utf8JsonReader</code>&nbsp;now supports reading multiple, whitespace-separated JSON documents from a single buffer or stream. By default,&nbsp;<code>Utf8JsonReader</code> will throw an exception if it detects any non-whitespace characters</p>\r\n<p><img src=\"https://docs.servicestack.net/img/pages/formats/system-text-json.png\" alt=\"\" width=\"478\" height=\"229\"></p>\r\n<h2 id=\"respecting-nullable-annotations\">Respecting nullable annotations</h2>\r\n<p><code>JsonSerializer</code>&nbsp;now adds limited support for non-nullable reference type enforcement in serialization and deserialization. This can be toggled using the&nbsp;<code>RespectNullableAnnotations</code> flag:</p>\r\n<h3 id=\"limitations\">Limitations</h3>\r\n<p>Due to how non-nullable reference types are implemented, this feature comes with an important number of limitations that users need to familiarize themselves&nbsp;</p>\r\n<ul>\r\n<li>Top-level types, aka the type that is passed when making the first&nbsp;<code>JsonSerializer.(De)serialize</code>&nbsp;call.</li>\r\n<li>Collection element types, aka we cannot distinguish between&nbsp;<code>List&lt;string&gt;</code>&nbsp;and&nbsp;<code>List&lt;string?&gt;</code>&nbsp;types.</li>\r\n<li>Any properties, fields, or constructor parameters that are generic.</li>\r\n</ul>\r\n<p>If you are looking to add nullability enforcement in these cases, we recommend that you either model your type to be a struct (since they do not admit&nbsp;<code>null</code>&nbsp;values) or author a custom converter that overrides its&nbsp;<a href=\"https://learn.microsoft.com/dotnet/api/system.text.json.serialization.jsonconverter-1.handlenull\" target=\"_blank\" rel=\"noopener\"><code>HandleNull</code></a>&nbsp;property to&nbsp;<code>true</code>.</p>",
                            DatePosted = new DateTime(2020, 6, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            DateUpdated = new DateTime(2020, 6, 11, 0, 0, 0, 0, DateTimeKind.Utc),
                            Description = "The 9.0 release of System.Text.Json includes many features, primarily with a focus on JSON schema and intelligent application support. It also includes highly requested enhancements such as nullable reference type support, customizing enum member names, out-of-order metadata deserialization and customizing serialization indentation.",
                            Slug = "whats-new-in-system-text-json-in-dotnet-9-lorem-ipsum-post-10",
                            Title = "What’s new in System.Text.Json in .NET 9 (lorem ipsum post)10"
                        });
                });
#pragma warning restore 612, 618
        }
    }
}
